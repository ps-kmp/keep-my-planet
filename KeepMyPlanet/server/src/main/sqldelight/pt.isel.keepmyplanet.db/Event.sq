import kotlinx.datetime.LocalDateTime;
import pt.isel.keepmyplanet.domain.common.Description;
import pt.isel.keepmyplanet.domain.common.Id;
import pt.isel.keepmyplanet.domain.event.EventStatus;
import pt.isel.keepmyplanet.domain.event.Title;

CREATE TABLE events (
    id BIGINT AS Id PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    title TEXT AS Title NOT NULL,
    description TEXT AS Description NOT NULL,
    start_datetime TIMESTAMP AS LocalDateTime NOT NULL,
    end_datetime TIMESTAMP AS LocalDateTime,
    zone_id BIGINT AS Id NOT NULL,
    organizer_id BIGINT AS Id NOT NULL,
    status TEXT AS EventStatus NOT NULL,
    max_participants INTEGER,
    pending_organizer_id BIGINT AS Id,
    transfer_request_time TIMESTAMP AS LocalDateTime,
    created_at TIMESTAMP AS LocalDateTime NOT NULL,
    updated_at TIMESTAMP AS LocalDateTime NOT NULL
);

CREATE TABLE event_participants (
    event_id BIGINT AS Id NOT NULL,
    user_id BIGINT AS Id NOT NULL,
    PRIMARY KEY (event_id, user_id),
    FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

CREATE TABLE event_attendances (
    event_id BIGINT AS Id NOT NULL,
    user_id BIGINT AS Id NOT NULL,
    checked_in_at TIMESTAMP AS LocalDateTime NOT NULL,
    PRIMARY KEY (event_id, user_id),
    FOREIGN KEY (event_id) REFERENCES events(id) ON DELETE CASCADE,
    FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE
);

addAttendance:
INSERT INTO event_attendances(event_id, user_id, checked_in_at)
VALUES (:event_id, :user_id, :checked_in_at);

getAttendanceByEventAndUser:
SELECT 1 FROM event_attendances WHERE event_id = :event_id AND user_id = :user_id;

getAttendeesIdsForEvent:
SELECT user_id FROM event_attendances WHERE event_id = :event_id;

findEventsAttendedByUser:
SELECT e.*
FROM events e
JOIN event_attendances ea ON e.id = ea.event_id
WHERE ea.user_id = :user_id
ORDER BY e.start_datetime DESC
LIMIT :limit OFFSET :offset;

countAttendedEvents:
SELECT COUNT(DISTINCT e.id) FROM event_attendances AS ea
JOIN events AS e ON ea.event_id = e.id
WHERE ea.user_id = :userId AND e.status = 'COMPLETED';

calculateTotalHoursVolunteered:
SELECT
  SUM(
    EXTRACT(EPOCH FROM (e.end_datetime - e.start_datetime))
  ) AS total_seconds
FROM events AS e
JOIN event_attendances AS ea
  ON e.id = ea.event_id
WHERE ea.user_id = :userId
  AND e.status = 'COMPLETED'
  AND e.end_datetime IS NOT NULL;

insert:
INSERT INTO events(title, description, start_datetime, end_datetime, zone_id, organizer_id, status, max_participants, pending_organizer_id, transfer_request_time, created_at, updated_at)
VALUES (
    :title, :description,
    :start_datetime, :end_datetime,
    :zone_id, :organizer_id, :status, :max_participants,
    :pending_organizer_id, :transfer_request_time,
    :created_at, :updated_at
)
RETURNING *;

getById:
SELECT * FROM events WHERE id = :id;

getAll:
SELECT * FROM events ORDER BY start_datetime DESC LIMIT :limit OFFSET :offset;

findEventsToStart:
SELECT *
FROM events
WHERE status = 'PLANNED' AND start_datetime <= :currentTime;

updateEvent:
UPDATE events
SET title = :title,
    description = :description,
    start_datetime = :start_datetime,
    end_datetime = :end_datetime,
    zone_id = :zone_id,
    organizer_id = :organizer_id,
    status = :status,
    max_participants = :max_participants,
    pending_organizer_id = :pending_organizer_id,
    transfer_request_time = :transfer_request_time,
    updated_at = :updated_at
WHERE id = :id
RETURNING *;

updateTransferStatus:
UPDATE events
SET organizer_id = :new_organizer_id,
    pending_organizer_id = NULL,
    transfer_request_time = NULL,
    updated_at = :updated_at
WHERE id = :id AND pending_organizer_id = :pending_organizer_id
RETURNING *;

clearPendingTransfer:
UPDATE events
SET pending_organizer_id = NULL,
    transfer_request_time = NULL,
    updated_at = :updated_at
WHERE id = :id
RETURNING *;

deleteByIdReturningId:
DELETE FROM events WHERE id = :id RETURNING id;

findByName:
SELECT * FROM events
WHERE title ILIKE ('%' || :name || '%')
ORDER BY start_datetime DESC
LIMIT :limit OFFSET :offset;

findByZoneAndName:
SELECT * FROM events
WHERE zone_id = :zoneId AND title LIKE ('%' || :name || '%')
ORDER BY start_datetime;

findByOrganizerId:
SELECT * FROM events
WHERE organizer_id = :organizerId
ORDER BY start_datetime DESC
LIMIT :limit OFFSET :offset;

findByNameAndOrganizerId:
SELECT * FROM events
WHERE organizer_id = :organizerId AND title ILIKE ('%' || :name || '%')
ORDER BY start_datetime DESC
LIMIT :limit OFFSET :offset;

findByZoneId:
SELECT * FROM events WHERE zone_id = :zoneId ORDER BY start_datetime;

findByStatus:
SELECT * FROM events WHERE status = :status ORDER BY start_datetime;

getParticipantIdsForEvent:
SELECT user_id FROM event_participants WHERE event_id = :event_id;

getParticipantIdsForEvents:
SELECT event_id, user_id FROM event_participants WHERE event_id IN :eventIds;

addParticipantToEvent:
INSERT INTO event_participants(event_id, user_id)
VALUES (:event_id, :user_id)
ON CONFLICT (event_id, user_id) DO NOTHING;

removeParticipantFromEvent:
DELETE FROM event_participants WHERE event_id = :event_id AND user_id = :user_id;

removeAllParticipantsFromEvent:
DELETE FROM event_participants WHERE event_id = :event_id;

findByParticipantId:
SELECT e.*
FROM events e
JOIN event_participants ep ON e.id = ep.event_id
WHERE ep.user_id = :participantId
ORDER BY e.start_datetime DESC
LIMIT :limit OFFSET :offset;

findByNameAndParticipantId:
SELECT e.*
FROM events e
JOIN event_participants ep ON e.id = ep.event_id
WHERE ep.user_id = :participantId AND e.title ILIKE ('%' || :name || '%')
ORDER BY e.start_datetime DESC
LIMIT :limit OFFSET :offset;

getEventsWithZoneLocation:
SELECT
    e.id AS event_id, e.title, e.description, e.start_datetime, e.end_datetime, e.zone_id,
    e.organizer_id, e.status, e.max_participants, e.created_at, e.updated_at,
    z.latitude AS zone_latitude, z.longitude AS zone_longitude
FROM events e
JOIN zones z ON e.zone_id = z.id;

findEventsByZoneIds:
SELECT * FROM events WHERE zone_id IN :zoneIds;

findCompletedEventsPendingConfirmation:
SELECT e.*
FROM events e
JOIN zones z ON e.zone_id = z.id
WHERE e.status = 'COMPLETED'
  AND z.status = 'CLEANING_SCHEDULED'
  AND e.updated_at <= :timeThreshold;