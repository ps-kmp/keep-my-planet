import kotlinx.datetime.LocalDateTime;
import pt.isel.keepmyplanet.domain.common.Description;
import pt.isel.keepmyplanet.domain.common.Id;
import pt.isel.keepmyplanet.domain.zone.ZoneSeverity;
import pt.isel.keepmyplanet.domain.zone.ZoneStatus;

CREATE TABLE zones (
    id BIGINT AS Id PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,
    latitude DOUBLE PRECISION NOT NULL,
    longitude DOUBLE PRECISION NOT NULL,
    description TEXT AS Description NOT NULL,
    reporter_id BIGINT AS Id NOT NULL,
    event_id BIGINT AS Id,
    status TEXT AS ZoneStatus NOT NULL,
    zone_severity TEXT AS ZoneSeverity NOT NULL,
    is_active BOOLEAN NOT NULL DEFAULT TRUE,
    created_at TIMESTAMP AS LocalDateTime NOT NULL,
    updated_at TIMESTAMP AS LocalDateTime NOT NULL
);

CREATE TABLE zone_photos (
    zone_id BIGINT AS Id NOT NULL,
    photo_id BIGINT AS Id NOT NULL,
    photo_type TEXT NOT NULL,
    PRIMARY KEY (zone_id, photo_id),
    FOREIGN KEY (zone_id) REFERENCES zones(id) ON DELETE CASCADE,
    FOREIGN KEY (photo_id) REFERENCES photos(id) ON DELETE CASCADE
);

insert:
INSERT INTO zones(latitude, longitude, description, reporter_id, event_id, status, zone_severity, is_active, created_at, updated_at)
VALUES (:latitude, :longitude, :description, :reporter_id, :event_id, :status, :zone_severity, :is_active, :created_at, :updated_at)
RETURNING *;

getById:
SELECT * FROM zones WHERE id = :id;

getAll:
SELECT * FROM zones ORDER BY id LIMIT :limit OFFSET :offset;

getAllActive:
SELECT * FROM zones WHERE is_active = TRUE ORDER BY id LIMIT :limit OFFSET :offset;

updateZone:
UPDATE zones
SET latitude = :latitude,
    longitude = :longitude,
    description = :description,
    reporter_id = :reporter_id,
    event_id = :event_id,
    status = :status,
    zone_severity = :zone_severity,
    is_active = :is_active,
    updated_at = :updated_at
WHERE id = :id
RETURNING *;

deleteByIdReturningId:
DELETE FROM zones WHERE id = :id RETURNING id;

findByEventId:
SELECT * FROM zones WHERE event_id = :eventId;

findByReporterId:
SELECT * FROM zones WHERE reporter_id = :reporterId ORDER BY id;

findBySeverity:
SELECT * FROM zones WHERE zone_severity = :zoneSeverity ORDER BY id;

findByStatus:
SELECT * FROM zones WHERE status = :status ORDER BY id;

findInBoundingBox:
SELECT * FROM zones
WHERE latitude BETWEEN :minLat AND :maxLat
  AND longitude BETWEEN :minLon AND :maxLon
ORDER BY id;

findInBoundingBoxActive:
SELECT * FROM zones
WHERE latitude BETWEEN :minLat AND :maxLat
  AND longitude BETWEEN :minLon AND :maxLon
  AND is_active = TRUE
ORDER BY id;

getBeforePhotoIdsForZone:
SELECT photo_id FROM zone_photos WHERE zone_id = :zone_id AND photo_type = 'BEFORE';

getAfterPhotoIdsForZone:
SELECT photo_id FROM zone_photos WHERE zone_id = :zone_id AND photo_type = 'AFTER';

addPhotoToZone:
INSERT INTO zone_photos(zone_id, photo_id, photo_type)
VALUES (:zone_id, :photo_id, :photo_type)
ON CONFLICT (zone_id, photo_id) DO NOTHING;

removePhotoFromZone:
DELETE FROM zone_photos WHERE zone_id = :zone_id AND photo_id = :photo_id;

removeAllPhotosFromZone:
DELETE FROM zone_photos WHERE zone_id = :zone_id;